package Physical

import scala.math._
import scala.language.higherKinds

//a physical 3D system involves spatial vectors, for positions, displacements, forces.
//so we need to encode some vector algebra
//force is generated by a change in a potential, 
//we will provide the system pairwise potentials that are functions of the displacement between two positions
//then we need to convert these potentials to forces by taking a derivative.

//was getting too complicated, lets keep things simple and learn physics first


//more fundamental is mass,

//this should extend Ordered, figure out how

//interesting, but getting too involved, lets try to understand scala types and 
//implement physics types!

//after many attempts we give up and accept to use this code that produces long class toStrings
//the latest attempt is in scratch/ver2_1


object ChurchNumerals{
	//this is taken from an online blog of Jim MacBeath
	case class Equals[A >: B <: B, B]()

	trait CInt {
			type Succ <: CInt
			type Add[N <: CInt] <: CInt
			type Pred <: CInt
			type Sub[N <: CInt] <: CInt
			type Neg <: CInt
	}

	trait CPos extends CInt
	trait CNeg extends CInt

	class CSucc[P <: CPos] extends CPos {
			type Succ = CSucc[CSucc[P]]
			type Add[N <: CInt] = P#Add[N]#Succ
			type Pred = P
			type Sub[N <: CInt] = P#Sub[N]#Succ
			type Neg = P#Neg#Pred
	}

	class CPred[S <: CNeg] extends CNeg {
			type Succ = S
			type Add[N <: CInt] = S#Add[N]#Pred
			type Pred = CPred[CPred[S]]
			type Sub[N <: CInt] = S#Sub[N]#Pred
			type Neg = S#Neg#Succ
	}

	final class _0 extends CPos with CNeg {
			type Succ = CSucc[_0]
			type Add[N <: CInt] = N
			type Pred = CPred[_0]
			type Sub[N <: CInt] = N#Neg
			type Neg = _0
	}



	type +[N1<:CInt, N2<:CInt] = N1#Add[N2]
	type -[N1<:CInt, N2<:CInt] = N1#Sub[N2]

	type _1 = _0#Succ
	type _2 = _1#Succ
	type _3 = _2#Succ
	

}

object PHType
{
	import ChurchNumerals._
	
	//minimal requirements from a PHType
	trait PHType[L<:CInt, M<:CInt, T<:CInt, K<:CInt]{
		//implementations of PHType did not work if I used PHType[L, M, T, K] instead of Q here
		type Q <: PHType[L, M, T, K]
		def +(that: Q): Q
		def -(that: Q): Q
		def *(that: Double): Q
		def *:(that: Double): Q
		def /(that: Double): Q
	}
	
	class PHScalar[L<:CInt, M<:CInt,
                 T<:CInt,
                 K<:CInt](val value: Double) extends PHType[L, M, T, K]
  {
		type Q = PHScalar[L, M, T, K]

		def +(that: PHScalar[L,M,T,K]): PHScalar[L, M, T, K] =
      new PHScalar[L, M, T, K](this.value + that.value)

		def -(that: PHScalar[L,M,T,K]): PHScalar[L, M, T, K] =
      new PHScalar[L, M, T, K](this.value - that.value)

		def *[L2<:CInt, M2<:CInt, T2<:CInt, K2<:CInt](that: PHScalar[L2, M2, T2, K2]):
        PHScalar[L+L2, M+M2, T+T2, K+K2] =
			new PHScalar[L+L2, M+M2, T+T2, K+K2](this.value*that.value)

		def *[L2<:CInt, M2<:CInt, T2<:CInt, K2<:CInt](that: PHVector[L2, M2, T2, K2]):
        PHVector[L+L2, M+M2, T+T2, K+K2] =
			new PHVector[L+L2, M+M2, T+T2, K+K2](this*that.xval,
                                           this*that.yval,
                                           this*that.zval)

		def *(that: Double): PHScalar[L, M, T, K] =
      new PHScalar[L, M, T, K](this.value*that)

		def *:(that: Double): PHScalar[L, M, T, K] = this*that

		def /(that: Double): PHScalar[L, M, T, K] =
      new PHScalar[L, M, T, K](this.value/that)

		def /[L2<:CInt, M2<:CInt, T2<:CInt, K2<:CInt](that: PHScalar[L2, M2, T2, K2]) = 
			new PHScalar[L-L2, M-M2, T-T2, K-K2](this.value/that.value)

		def /(that: PHScalar[L, M, T, K]): Double = this.value/that.value
		
		def ==(that:PHScalar[L,M,T,K]) = (this.value == that.value)
		def !=(that:PHScalar[L,M,T,K]) = (this.value != that.value)
		def >(that:PHScalar[L,M,T,K]) = (this.value > that.value)
		def >=(that:PHScalar[L,M,T,K]) = (this.value >= that.value)
		def <(that:PHScalar[L,M,T,K]) = (this.value < that.value)
		def <=(that:PHScalar[L,M,T,K]) = (this.value <= that.value)


	}
	//now lets define some physical quantities
	//first the scalars are defined as types
	type Zcalar = PHScalar[_0, _0, _0, _0]
	type Length = PHScalar[_1, _0, _0, _0]
	type Area = PHScalar[_2, _0, _0, _0]
	type Volume = PHScalar[_3, _0, _0, _0]
	type Mass = PHScalar[_0, _1, _0, _0]
	type Time = PHScalar[_0, _0, _1, _0]
	type Temp = PHScalar[_0, _0, _0, _1]
	type Freq = PHScalar[_0, _0, _1#Neg, _1]
	type Speed = PHScalar[_1, _0, _1#Neg, _0]
	type Acc = PHScalar[_1, _0, _2#Neg, _0]
	type Force = PHScalar[_1, _1, _2#Neg, _0]
	type Energy = PHScalar[_2, _1, _2#Neg, _0]
	type Power = PHScalar[_2, _1, _3#Neg, _0]
	//it seems that even if X is a type alias for case class PHType, we need to use new PH...
	object Zcalar{
		def apply(x: Double) = new Zcalar(x)
	}
	object Length{
		def apply(x: Double) = new Length(x)
	}
	object Area{
		def apply(x: Double) = new Area(x)
	}
	object Volume{
		def apply(x: Double) = new Volume(x)
	}
	object Mass{
		def apply(x: Double) = new Mass(x)
	}
	object Time{
		def apply(x: Double) = new Time(x)
	}
	object Temp{
		def apply(x: Double) = new Temp(x)
	}
	object Freq{
		def apply(x: Double) = new Freq(x)
	}
	object Speed{
		def apply(x: Double) = new Speed(x)
	}
	object Acc{
		def apply(x: Double) = new Acc(x)
	}
	object Force{
		def apply(x: Double) = new Force(x)
	}
	object Energy{
		def apply(x: Double) = new Energy(x)
	}
	object Power{
		def apply(x: Double) = new Power(x)
	}

	//a double can be a scalar
	//implicit def toZcalar(d: Double) = new Zcalar(d)

	object amplitude{
		def apply(x: Double, y: Double, z: Double) = sqrt(x*x + y*y + z*z)
	}

	//what should be a vector?
	//lets be radical: a vector[X] is the vectorized form of [X]
	class PHVector[L<:CInt,
                 M<:CInt,
                 T<:CInt,
                 K<:CInt](val xval: PHScalar[L, M, T, K],
                          val yval: PHScalar[L, M, T, K],
                          val zval: PHScalar[L, M, T, K])
      extends PHType[L, M, T, K]
  {
		type Q = PHVector[L, M, T, K]
		
		def +(that: PHVector[L, M, T, K]) =
      new PHVector[L, M, T, K](this.xval + that.xval,
                               this.yval+ that.yval,
                               this.zval+ that.zval)

		def -(that: PHVector[L, M, T, K]) =
      new PHVector[L, M, T, K](this.xval- that.xval,
                               this.yval- that.yval,
                               this.zval- that.zval)

		def *[L2<:CInt, M2<:CInt, T2<:CInt, K2<:CInt](that: PHScalar[L2, M2, T2, K2]):
        PHVector[L+L2, M+M2, T+T2, K+K2] =
			new PHVector[L+L2, M+M2, T+T2, K+K2](this.xval* that,
                                           this.yval* that,
                                           this.zval* that)

		//multiplication with a Zcalar does not seem to work through
		def *(that: Double): PHVector[L, M, T, K] =
      new PHVector[L, M, T, K](this.xval*that, this.yval*that, this.zval*that)

		def *:(that: Double):PHVector[L, M, T, K] =  this*that

		def /(that: Double): PHVector[L, M, T, K] =
      new PHVector[L, M, T, K](this.xval/that, this.yval/that, this.zval/that)

		def /[L2<:CInt,
          M2<:CInt,
          T2<:CInt,
          K2<:CInt](that: PHScalar[L2, M2, T2, K2]) =
			new PHVector[L-L2, M-M2, T-T2, K-K2](this.xval/ that,
                                           this.yval/ that,
                                           this.zval/ that)

		def toDouble(s: PHScalar[L, M, T, K]): Double = s.value

		lazy val amp = new PHScalar[L, M, T, K](
      sqrt( (xval*xval+ yval*yval+ zval*zval).value)
    )

		lazy val dir = Direction(xval.value, yval.value, zval.value)
	}
	
	//a safe implicit conversion, NO SIR
	//implicit def toDouble(s: Zcalar) = s.value
	//this one is safe
	implicit def toZcalar(s: Double) = Zcalar(s)

	//some how L+_0 is considered different from L. This causes trouble.
	
	object PHVector{
		def apply[L<:CInt, M<:CInt, T<:CInt, K<:CInt](s: PHScalar[L, M, T, K],
                                                  u: Direction) = u*s
	}


	
	type Zector = PHVector[_0, _0, _0, _0] //can we think of a better name?
	type Position = PHVector[_1, _0, _0, _0]
	type Velocity = PHVector[_1, _0, _1#Neg, _0]
	type ForceVec = PHVector[_1, _1, _2#Neg, _0]
	type AccVec = PHVector[_1, _0, _2#Neg, _0]
	
	class Direction(v: Zector) extends PHVector[_0, _0, _0, _0](v.xval/v.amp,
                                                              v.yval/v.amp,
                                                              v.zval/v.amp)
	object Direction
  {
		def apply(x: Double, y: Double, z: Double): Direction =
      new Direction( Zector(x, y, z))
	}


	//case class Direction(x: Double, y: Double, z: Double) extends Zector(x/amplitude(x, y, z), y/amplitude(x, y, z), z/amplitude(x, y, z))

	object Zector
  {
		def apply(x: Double, y: Double, z: Double) =
      new Zector(Zcalar(x), Zcalar(y), Zcalar(z))
	}

	object Position
  {
		def apply(x: Double, y: Double, z: Double) =
      new Position(Length(x), Length(y), Length(z))

		def apply(x: Length, y: Length, z: Length) = new Position(x, y, z)

		def apply(l: Length, u: Direction) = l*u
	}
	object Velocity
  {
		def apply(x: Double, y: Double, z: Double) =
      new Velocity(Speed(x), Speed(y), Speed(z))

		def apply(x: Speed, y: Speed, z: Speed) = new Velocity(x, y, z)

		def apply(s: Speed, u: Direction) = s*u
	}
	object ForceVec
  {
		def apply(x: Double, y: Double, z: Double) =
      new ForceVec(Force(x), Force(y), Force(z))

		def apply(x: Force, y: Force, z: Force) = new ForceVec(x, y, z)

		def apply(f: Force, u: Direction) = f*u
	}
	object AccVec
  {
		def apply(x: Double, y: Double, z: Double) =
      new AccVec(Acc(x), Acc(y), Acc(z))

		def apply(x: Acc, y: Acc, z: Acc) = new AccVec(x, y, z)

		def apply(a: Acc, u: Direction) = a*u
	}

}

object Field{
	
/*
	this is an example of type classes in Scala.
	using implicit implementations of Field[T] we define operations on fields,
	like the sum of several fields
	advantage vs defining a trait over dimension parameters LMTK: this does not require LMTK
	so as it is it could be used for any type T that we can define a field over, 
	defining a field over T requires an implicit object . . .
*/
	
	//type P can be context bound as PHSpace,
	//we do not have any requirements from PHSpace yet

	//needed to be carefull in order to use this Field for functions P => P => T
	//the idea of Field should be constrained to types P that act as a Position
	trait Field[P, T]
  {
		def plus(f: P => T, g: P => T): P => T
		def minus(f: P => T, g: P => T): P => T
		def scale(f: P => T, s: Double): P => T
		def identity: P => T
	}
	
//the sum over functions needs to be saved in a val to be evaluated
	def sum[P, T](fs: Seq[P => T])(implicit evP: Field[P, T]): P => T = fs match{
		case Nil => evP.identity
		case f::gs => evP.plus(f, sum(gs))
	}
}

object SummableScalable{
	
	//a step back from Field
	trait SummableScalable[T]
  {
		def identity: T 
		def plus(f: T, g: T): T
		def minus(f: T, g: T): T
		def scale(f: T, s: Double): T
	}

	def sum[T: SummableScalable](fs: Seq[T]): T = fs match {
		case Nil => implicitly[SummableScalable[T]].identity
		case x::xs => implicitly[SummableScalable[T]].plus(x, sum(xs))
	}
}

object PHField
{
	/* 
		some implicit objects to be used to implement Fields of different kinds
	*/
	import PHType._, Field._, SummableScalable._
	

/*
	implicit object InterForceField extends InterField[ForceVec]{
		def plus[Position](f: Position => Position => ForceVec, g: Position => Position => ForceVec)  = (r1: Position) => (r2: Position) => f(r1)(r2) + g(r1)(r2)
		def minus[Position](f: Position => Position => ForceVec, g: Position => Position => ForceVec) = (r1: Position) => (r2: Position) => f(r1)(r2) - g(r1)(r2)
		def scale[Position](f: Position => Position => ForceVec, s: Double)  = (r1: Position) => (r2: Position) => f(r1)(r2)*s
	}
*/

//ok, curryied functions cant be decomposed, P => P => F can not be thought of as (P=>P)=>F.
//P=>P is a function that takes a P and returns a P. 
//What we want is func(r: P)(r1: P): F. 
//what we want is a Field, so that should be Position => some type 
	implicit object ForceField extends Field[Position, ForceVec]
  {
		def plus(f: Position => ForceVec,
             g: Position => ForceVec): Position => ForceVec  =
      (r1: Position) =>  f(r1) + g(r1)
		def minus(f: Position => ForceVec,
              g: Position => ForceVec) = (r1: Position) =>  f(r1) - g(r1)

		def scale(f: Position => ForceVec, s: Double) =
      (r1: Position) =>  f(r1)*s

		def identity = (r1: Position) =>  ForceVec(0.0, 0.0, 0.0)
	}

	type ForceAtPosition = Position => ForceVec

	implicit object TwoParticleForce extends Field[Position, ForceAtPosition]
  {
		def plus( f: Position => ForceAtPosition,
              g: Position => ForceAtPosition) =
				(r1: Position) => { (r2: Position) => f(r1)(r2) + g(r1)(r2)}

		def minus( f: Position => ForceAtPosition,
               g: Position => ForceAtPosition) =
				(r1: Position) => { (r2: Position) => f(r1)(r2) - g(r1)(r2)}

		def scale(f: Position => ForceAtPosition, s: Double) = 
				(r1: Position) => { (r2: Position) => f(r1)(r2)*s}

		def identity = (r1: Position) => { (r2: Position) => ForceVec(0.0, 0.0, 0.0)}
	}

	implicit object ForceFieldSummable
      extends SummableScalable[Position => ForceVec]
  {
		def plus(f: Position => ForceVec,
             g: Position => ForceVec): Position => ForceVec =
      (r1: Position) =>  f(r1) + g(r1)

		def minus(f: Position => ForceVec,
              g: Position => ForceVec) =
      (r1: Position) =>  f(r1) - g(r1)

		def scale(f: Position => ForceVec, s: Double) = (r1: Position) =>  f(r1)*s

		def identity = (r1: Position) => ForceVec(0.0, 0.0, 0.0)
	}

	//this declaration is necessary to use Field.sum

}


object FieldExample
{
	import  PHField._, scala.math.pow, PHType._
	
	//we use the convention Force a b as force of a ON b, seems this goes well with function composition
	//def lj(e: Energy, s: Length): Position => Position  => ForceVec =  (r1: Position) => (r2: Position) => {
	def lj(e: Energy, s: Length): Position => ForceAtPosition = (r1: Position) => {
		(r2: Position) => {
			val r = r1 - r2
      val lj = 48.0*(e/r.amp)*(pow( s/r.amp, 12.0) - 0.5*pow( s/r.amp, 6.0))
			ForceVec(lj, r.dir)
		}
	}

	val f = lj(Energy(1.0), Length(1.0))
	val g =  lj(Energy(1.0), Length(2.0))

	val fs = List(f, g)
	val h = Field.sum(fs)
}
	
			
